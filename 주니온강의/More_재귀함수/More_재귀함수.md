<style>
.imgOption{
    display:flex;
    justify-content:center;
    align-items:center;
    height: 600px; 
}
h2{
    font-weight :bold;
    border : 6px solid #DC143C;
    color : #DC143C !important;
}
h3 {
    font-weight :bold;
    border : 3px solid ;
}
</style>

## 재귀함수
### Quest
#### ❗ 용어 정리
##### 👉 재귀함수의 구성
1. 재귀호출
   * 문제 해결을 위해 부분 문제에 대해 자기 자신을 호출하는것
2. 종료조건
   * 재귀 호출을 종료할 수 있는 시점

#### ❗ 어떻게 사용해야하나
##### 👉 잘짜는 방법
1. 종료조건이 무엇인지 생각한다
2. 문제 집합을 분할하여 부분문제에 대해 재귀호출한다
   * 분할 정복이야기다..
3. 부분 문제의 해답을 이용해 문제 집합의 해답을 리턴한다
   * 동적 계획법 이야기다.

### 대표적인 문제
#### ❗ 1. 팩토리얼 
##### 👉 참고
* 팩토리얼은 증가하는 속도가 너무 크니.. 
웬만해선 큰수곱셈을 제공하는 파이썬이든.
아니면 큰수곱셈하는 함수를 만들고 FFT 하는게 내 소원 
##### 👉 코드
*
    ```cpp
    #include <iostream>
    #define ll long long
    using namespace std;

    ll DP[10101] ={0,};

    ll fac(int n) {
        if(n <= 2){ return DP[n] = n;}
        if(DP[n] != 0){ return DP[n];}
        return DP[n] =  n * fac(n-1);
    }

    int main(){
    	int N; cin >> N;
        cout << fac(N) << '\n';
    }
    ```

---

#### ❗ 2. 피보나치
👉 **[설명문](././../2_동적계획/2_DP_피보나치.md)**

---

#### ❗ 3. 최대공약수 (유클리드 호제법)
##### 👉 입력
* A와 B가 들어온다
  * 단, A는 B보다 크다.
##### 👉 코드
*    
    ```cpp
    int GCD(int a, int b) {return b ? a : GCD(b, a % b)}
    int LCM = GCD(a,b) * a * b;
    ```

---

#### ❗ 4. 하노이탑
##### 👉 구성
1. 원반
   * 순차적으로 커지는 원반들
2. 막대
   * A , B, C
   * 시작지, 경유지, 목적지

3. 조건
   * 한번에 하나의 원반만 이동할 수 있음
   * 한번에 하나의 원반만 이동할 수 있음
   * 작은 원반 위에 큰 원반을 올릴수 없다
4. 문제 종류
   1. 디스크를 몇번 음직였나?
   2. 디스크의 음직이는 순서?

##### 👉 입력
디스크의 개수 N

##### 👉 해결
* 점근적
  1. 1개 일때는 그냥 옮기면 된다
  2. n-1개의 하노의 탑은 n-2개의 하노이 탑을 해결해야한다.
  3. 옮겼다는것은 Print 로 보여주자 ㅋㅋ
* 재귀함수
  * 종료 조건
    * n == 1 : A -> C
  * 재귀호출
    * n - 1개의 디스크를 B로 옮김 
    * 남은 하나의 디스크를 A -> C
      * 종료 조건 실행
    * B에 있던 n - 1개의 디스크를 C로 옮김

---